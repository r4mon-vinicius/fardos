
## Documentação Completa do Código: `analisar_alinhamento_fardo`

### 1\. Visão Geral

Este script foi projetado para realizar uma análise de visão computacional em imagens de fardos de garrafas. Seu principal objetivo é determinar o status de um fardo com base em três critérios principais:

1.  **Alinhamento:** Verifica se as garrafas estão organizadas em uma grade (linhas e colunas) uniforme.
2.  **Tipo de Fardo:** Identifica a configuração do fardo, como por exemplo, 4x3 (4 colunas e 3 linhas).
3.  **Integridade:** Determina se o fardo está completo (com todas as garrafas esperadas) ou incompleto (com garrafas faltando).

Para alcançar isso, o script utiliza um modelo de detecção de objetos **YOLOv8** para localizar as garrafas na imagem e, em seguida, aplica algoritmos de processamento de imagem e análise de dados para interpretar a disposição espacial dos itens detectados.

### 2\. Principais Tecnologias e Bibliotecas

O código depende das seguintes bibliotecas Python:

  * **OpenCV (`cv2`):** Uma biblioteca fundamental para tarefas de visão computacional. É usada para:

      * Ler e escrever imagens (`cv2.imread`, `cv2.imshow`).
      * Desenhar formas e textos na imagem (`cv2.rectangle`, `cv2.circle`, `cv2.putText`).
      * Realizar transformações geométricas, como rotação (`cv2.getRotationMatrix2D`, `cv2.transform`).
      * Analisar formas, como encontrar o retângulo de área mínima (`cv2.minAreaRect`).

  * **NumPy (`np`):** A biblioteca principal para computação numérica em Python. É essencial para:

      * Manipular arrays de forma eficiente, especialmente as coordenadas dos pontos.
      * Realizar cálculos matemáticos, como a média (`np.mean`).
      * Formatar dados para as funções do OpenCV.

  * **Ultralytics (`YOLO`):** A biblioteca oficial para usar os modelos YOLO (You Only Look Once). Neste script, ela é usada para:

      * Carregar um modelo YOLOv8 pré-treinado (`YOLO(caminho_modelo)`).
      * Executar a inferência (detecção de objetos) em uma imagem (`modelo(imagem)`).

  * **OS (`os`):** Fornece uma maneira de usar funcionalidades dependentes do sistema operacional. Aqui, é usado para:

      * Verificar se os arquivos (imagem e modelo) existem (`os.path.exists`).
      * Construir caminhos de arquivo de forma segura (`os.path.join`).

  * **Collections (`defaultdict`):** Uma subclasse de dicionário que fornece um valor padrão para chaves que ainda não existem. É usada para agrupar os centros das garrafas em linhas de forma mais conveniente.

-----

### 3\. Fluxo de Execução Detalhado da Função `analisar_alinhamento_fardo`

A função principal pode ser dividida em 5 etapas lógicas.

#### Etapa 1: Validação e Carregamento

**Propósito:** Garantir que todos os recursos necessários (imagem e modelo) estejam disponíveis antes de iniciar o processamento e carregá-los na memória.

```python
# --- 1. Validação e Carregamento ---
if not os.path.exists(caminho_imagem):
    print(f"Erro: Imagem não encontrada em '{caminho_imagem}'")
    return None, "Erro: Imagem não encontrada"
if not os.path.exists(caminho_modelo):
    print(f"Erro: Modelo não encontrado em '{caminho_modelo}'")
    return None, "Erro: Modelo não encontrado"

try:
    modelo = YOLO(caminho_modelo)
except Exception as e:
    print(f"Erro ao carregar o modelo: {e}")
    return None, "Erro ao carregar modelo"

imagem = cv2.imread(caminho_imagem)
imagem_resultado = imagem.copy()
```

**Explicação:**

1.  **Verificação de Arquivos:** O `os.path.exists()` verifica se os caminhos para a imagem e para o modelo `.pt` são válidos. Se um deles não existir, a função retorna imediatamente com uma mensagem de erro, evitando falhas posteriores.
2.  **Carregamento do Modelo:** `modelo = YOLO(caminho_modelo)` instancia o modelo de detecção de objetos a partir do arquivo de pesos especificado. Um bloco `try...except` é usado para capturar possíveis erros durante o carregamento (ex: arquivo corrompido).
3.  **Carregamento da Imagem:** `imagem = cv2.imread(caminho_imagem)` lê o arquivo de imagem e o carrega como um array NumPy.
4.  **Cópia da Imagem:** `imagem_resultado = imagem.copy()` cria uma cópia da imagem original. Isso é uma boa prática para que todos os desenhos (retângulos, círculos, texto) sejam feitos na cópia, preservando a imagem original intacta.

#### Etapa 2: Detecção de Objetos

**Propósito:** Utilizar o modelo YOLOv8 para encontrar todas as garrafas presentes na imagem.

```python
# --- 2. Detecção de Objetos ---
resultados = modelo(imagem, verbose=False)
```

**Explicação:**

  * `modelo(imagem)` executa o processo de inferência. O modelo analisa a imagem e retorna uma lista de objetos `resultados`.
  * Cada `resultado` na lista contém informações sobre os objetos detectados, incluindo suas caixas delimitadoras (`boxes`), classes e pontuações de confiança (`conf`).
  * `verbose=False` é usado para evitar que a biblioteca YOLO imprima logs detalhados no console durante a detecção, mantendo a saída limpa.

#### Etapa 3: Extração dos Pontos Centrais

**Propósito:** Processar os resultados brutos da detecção para extrair informações úteis: as coordenadas do centro e a altura de cada garrafa detectada.

```python
# --- 3. Extração dos Pontos Centrais ---
centros = []
alturas_caixas = []
for resultado in resultados:
    boxes = resultado.boxes.cpu().numpy()
    for box in boxes:
        x1, y1, x2, y2 = map(int, box.xyxy[0])
        confianca = box.conf[0]
        
        if confianca > 0.5:
            cv2.rectangle(imagem_resultado, (x1, y1), (x2, y2), (255, 0, 0), 2)
            centro_x = int((x1 + x2) / 2)
            centro_y = int((y1 + y2) / 2)
            centros.append((centro_x, centro_y))
            alturas_caixas.append(y2 - y1)
```

**Explicação:**

1.  **Iteração:** O código itera sobre cada `resultado` da detecção e depois sobre cada `box` (caixa delimitadora) encontrada.
2.  **Filtragem por Confiança:** `if confianca > 0.5:` é um passo crucial. A detecção de objetos nem sempre é perfeita. O modelo atribui uma pontuação de confiança (de 0 a 1) para cada detecção. Este filtro descarta detecções fracas (abaixo de 50% de confiança), reduzindo a chance de falsos positivos.
3.  **Cálculo do Centro:** Para cada caixa delimitadora `(x1, y1, x2, y2)`, o ponto central é calculado pela média das coordenadas X e Y: $centro\_x = (x1 + x2) / 2$ e $centro\_y = (y1 + y2) / 2$.
4.  **Armazenamento:** Os centros `(centro_x, centro_y)` e as alturas `(y2 - y1)` são armazenados em listas para análise posterior. A altura será usada para definir uma tolerância dinâmica no alinhamento.
5.  **Desenho (Feedback Visual):** `cv2.rectangle(...)` desenha um retângulo azul na `imagem_resultado` para cada garrafa detectada com confiança suficiente.

#### Etapa 4: Análise de Grade (O Coração da Lógica)

**Propósito:** Transformar a nuvem de pontos centrais em uma grade estruturada (linhas e colunas) para verificar o alinhamento e a integridade do fardo.

```python
# --- 4. Análise de Grade ---
status_alinhamento = "Nao Alinhado"
cor_status = (0, 0, 255) # Vermelho por padrão

if len(centros) >= 4:
    # ... (lógica detalhada abaixo)
```

Esta etapa é a mais complexa e pode ser subdividida:

##### 4.1. Correção de Rotação

**Problema:** O fardo na imagem pode estar ligeiramente inclinado. Se tentarmos agrupar as garrafas em linhas usando apenas suas coordenadas `y`, uma pequena rotação pode fazer com que garrafas da mesma linha pareçam estar em alturas diferentes.

**Solução:** O script calcula o ângulo de inclinação do grupo de pontos e "rotaciona" virtualmente suas coordenadas para que fiquem perfeitamente alinhados horizontalmente.

```python
rect = cv2.minAreaRect(pontos)
angulo = rect[2]
matriz_rotacao = cv2.getRotationMatrix2D(tuple(rect[0]), angulo, 1.0)
pontos_rotacionados = cv2.transform(np.array([pontos]), matriz_rotacao)[0]
```

  * `cv2.minAreaRect(pontos)`: Esta função encontra o retângulo de área mínima que pode conter todos os pontos centrais. O importante é que este retângulo nos dá o ângulo de inclinação (`angulo`) do grupo de pontos.
  * `cv2.getRotationMatrix2D(...)`: Cria uma matriz de transformação para rotacionar os pontos em torno do centro do retângulo (`rect[0]`) pelo ângulo calculado.
  * `cv2.transform(...)`: Aplica a matriz de rotação a todos os pontos, gerando `pontos_rotacionados` que agora estão alinhados com os eixos.

##### 4.2. Agrupamento em Linhas

**Problema:** Agora que os pontos estão rotacionados, precisamos agrupá-los em linhas.

**Solução:** O script itera sobre os pontos (ordenados por altura) e os agrupa se suas coordenadas `y` estiverem próximas, dentro de uma tolerância.

```python
# Ordena pontos por Y, depois por X
pontos_rotacionados = sorted(pontos_rotacionados, key=lambda p: (p[1], p[0]))

# Define tolerância vertical dinâmica
altura_media = np.mean(alturas_caixas)
TOLERANCIA_Y = altura_media * 0.5

# Agrupa pontos em linhas
linhas = defaultdict(list)
# ... lógica de iteração e agrupamento ...
```

  * **Ordenação:** Os pontos são ordenados primeiro pela coordenada `y` e depois pela `x`. Isso garante que processamos as garrafas de cima para baixo e, dentro de cada linha, da esquerda para a direita.
  * **Tolerância Dinâmica:** `TOLERANCIA_Y = altura_media * 0.5` é uma abordagem inteligente. Em vez de usar um valor fixo (ex: 20 pixels), a tolerância para agrupar pontos na mesma linha é baseada na altura média das garrafas detectadas. Isso torna o algoritmo robusto a diferentes escalas de imagem (fotos tiradas de perto ou de longe).
  * **Agrupamento:** O código percorre os pontos ordenados. Ele pega o primeiro ponto como referência de uma nova linha. Os pontos seguintes que estiverem dentro da `TOLERANCIA_Y` são adicionados à mesma linha. Quando um ponto está fora da tolerância, ele se torna a referência para a próxima linha. `defaultdict(list)` simplifica a adição de pontos a novas linhas.

##### 4.3. Lógica de Decisão

**Propósito:** Com base na grade identificada, decidir o status final do fardo.

```python
contagens_por_linha = [len(l) for l in linhas.values()]
max_cols = max(contagens_por_linha)  # número de colunas esperado
num_linhas = len(linhas)            # número de linhas
esperado = max_cols * num_linhas
detectado = len(centros)

if detectado < esperado:
    # ... Lógica para fardo INCOMPLETO
elif len(set(contagens_por_linha)) == 1 and detectado == esperado:
    # ... Lógica para fardo ALINHADO e COMPLETO
else:
    # ... Lógica para fardo NÃO ALINHADO
```

  * **Cálculos:** O script determina:

      * `num_linhas`: O número de linhas encontradas.
      * `max_cols`: O número máximo de garrafas em qualquer linha (considerado o número de colunas do fardo).
      * `esperado`: O número total de garrafas que um fardo completo deveria ter (`num_linhas * max_cols`).
      * `detectado`: O número total de garrafas realmente encontradas.

  * **Regras de Decisão:**

    1.  **Incompleto:** Se `detectado` for menor que `esperado`, significa que faltam garrafas. O status indica um fardo incompleto e a cor é definida como laranja.
    2.  **Alinhado e Completo:** A condição `len(set(contagens_por_linha)) == 1` é a chave para o alinhamento. `set(contagens_por_linha)` cria um conjunto com as contagens de itens por linha. Se o tamanho desse conjunto for `1`, significa que todas as linhas têm exatamente o mesmo número de garrafas. Se isso for verdade E `detectado == esperado`, o fardo é considerado "Alinhado" e a cor é verde.
    3.  **Não Alinhado:** Se nenhuma das condições acima for atendida, significa que as linhas têm contagens diferentes (ex: uma linha com 4 garrafas e outra com 3). O fardo é "Nao Alinhado" e a cor é vermelha.

#### Etapa 5: Desenho do Resultado

**Propósito:** Adicionar informações visuais à imagem de resultado para que o usuário possa entender a análise.

```python
# --- 5. Desenho do Resultado ---
for ponto in centros:
    cv2.circle(imagem_resultado, (int(ponto[0]), int(ponto[1])), 5, (0, 0, 255), -1)

cv2.putText(imagem_resultado, status_alinhamento, (50, 50), 
            cv2.FONT_HERSHEY_SIMPLEX, 1.0, cor_status, 2, cv2.LINE_AA)

return imagem_resultado, status_alinhamento
```

  * `cv2.circle(...)`: Desenha um pequeno círculo vermelho no centro de cada garrafa detectada originalmente.
  * `cv2.putText(...)`: Escreve o texto do `status_alinhamento` final no canto superior esquerdo da imagem, usando a cor (`cor_status`) que foi definida na etapa de decisão.
  * `return`: A função retorna a imagem final com todos os desenhos e a string de status.

-----

### 4\. Análise do Bloco Principal (`if __name__ == "__main__":`)

**Propósito:** Este bloco define como o script deve ser executado quando chamado diretamente (não quando importado como um módulo).

```python
if __name__ == "__main__":
    MODELO_PATH = "pesos/best.pt"
    NOME_IMAGEM = "fardo_teste2.jpg"
    CONTAGEM_ESPERADA = None # opcional, pode forçar validação extra

    IMAGEM_TESTE_PATH = os.path.join("imagens_teste", NOME_IMAGEM)
    print(f"Analisando a imagem: {IMAGEM_TESTE_PATH}")

    imagem_final, status = analisar_alinhamento_fardo(IMAGEM_TESTE_PATH, MODELO_PATH, CONTAGEM_ESPERADA)

    if imagem_final is not None:
        print(f"Resultado da análise: {status}")
        cv2.imshow("Resultado da Analise", imagem_final)
        cv2.waitKey(0)
        cv2.destroyAllWindows()
```

**Explicação:**

1.  **Configuração:** Define as variáveis para os caminhos do modelo e da imagem. Isso facilita a alteração da imagem ou do modelo a ser testado.
2.  **Chamada da Função:** Invoca a função `analisar_alinhamento_fardo` com os caminhos definidos.
3.  **Exibição do Resultado:**
      * Verifica se a função retornou uma imagem (`if imagem_final is not None`).
      * Imprime o status final no console.
      * `cv2.imshow(...)`: Abre uma janela para exibir a imagem resultante.
      * `cv2.waitKey(0)`: Pausa a execução e espera que o usuário pressione qualquer tecla. Sem isso, a janela fecharia instantaneamente.
      * `cv2.destroyAllWindows()`: Fecha todas as janelas abertas pelo OpenCV.

### 5\. Possíveis Melhorias e Observações

  * **Uso do `CONTAGEM_ESPERADA`:** O parâmetro `contagem_esperada` é definido na função, mas não é utilizado na lógica de decisão. Ele poderia ser usado para uma validação extra, por exemplo: `if detectado != CONTAGEM_ESPERADA: status = "Contagem incorreta"`.
  * **Robustez:** O algoritmo é sensível à qualidade da detecção do YOLO. Se o modelo não detectar uma garrafa, o algoritmo a considerará "faltante", mesmo que ela esteja fisicamente presente.
  * **Casos Extremos:** O requisito `if len(centros) >= 4:` impede a análise de fardos muito pequenos ou com muitas falhas de detecção. Esse limite pode ser ajustado dependendo do caso de uso.
  * **Parâmetros:** Valores como o limiar de confiança (`0.5`) e o multiplicador da tolerância (`0.5`) podem ser expostos como parâmetros da função para permitir um ajuste mais fino.